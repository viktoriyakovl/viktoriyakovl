> [!NOTE]
> Пример архитектурного предложения

# Микросервис для централизованного управления медиафайлами

## Проблематика

*   **Используем ImageGroup:** хранится в Redis, сложная реализация.<br>Для добавления нового типа изображений нужно добавить новую `ImageGroup` и настроить загрузку/получение медиафайлов из нее на Frontend.
*   **Кэширование:** Медиафайл сохраняем с тем же идентификатором, что и товар/новость/баннер и т.д.<br>Это усложняет замену изображений (проблема с инвалидацией кэша).
*   **Сложная архитектура:** Для отображения медиафайлов пользователю Frontend отправляет несколько запросов в разные микросервисы, консолидирует полученную информацию и уже с ней идет на CDN.
*   **Лишние запросы:** Идентификатор медиафайла храним в микросервисе `Content`, хотя он идентичен идентификатору товара/новости/баннера.
*   **Разные подходы к оперированию и хранению идентификаторов:**
    *   *Товары:* хранятся в микросервисе `Content` с фиксацией типа изображения в `ImageGroup`.
    *   *Баннеры:* хранятся в БД микросервиса `Media` (в формате `jsonb`) ссылки на CDN (без хоста и бакета), изображения на CDN нужно загружать вручную.
    *   *Новости:* хранятся в БД микросервиса `News` в виде ссылок на CDN (в формате `jsonb`), нужна новая `ImageGroup` для загрузки изображений через Admin-panel.
    *   *Обложки игр:* захардкожены на Frontend.

## Цель

1.  Решить проблему с заменой/обновлением изображений.
2.  Выработать единый масштабируемый подход к оперированию и хранению медиафайлов.
3.  Упростить схему получения Frontend пути до изображения на CDN.

---

## Целевое решение

<mark>Разработать новый микросервис **MediaContent** для централизованного управления медиафайлами.</mark>

> [!NOTE]
> `Media` ≠ `MediaContent`<br>`Content` ≠ `MediaContent`

**Основные задачи:**
*   Загрузка, замена и удаление медиафайлов на CDN, хранение идентификаторов медиафайлов.
*   Хранение метаданных (размер, тип, разрешение).
*   Генерация уникальных идентификаторов медиафайлов (отличный от идентификатора соответствующего контента).
*   Генерация URL для доступа через CDN (без хоста и бакета).

Микросервис `MediaContent` должен иметь свою БД, а также **shared-библиотеку** для интеграции с микросервисами, использующими медиафайлы.

### Структура БД

#### Таблица `media_files`

| Ключ | Поле | Тип | Описание | Параметры | Пример |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **PK**| **id** | `uuid` | Уникальный идентификатор файла<br>Генерируется сервисом `MediaContent`, не связан с ID контента | - UNIQUE<br>- NOT NULL | 00002afb-846e... |
| | **slug** | `text` | Человекочитаемый идентификатор<br>_(например, тип контента)_ | | news |
| | **url** | `text` | Относительный путь к файлу в хранилище<br><br>Базовый хост CDN хранится в конфигурационном файле | - NOT NULL | video/rq/news/00002afb...avi |
| | **metadata**| `jsonb` | Дополнительные данные: размер, MIME-тип, разрешение | |  {<br>"size":"10KB",<br>"px":"500x500"<br>} |
| | **when_created**| `timestamp`| Дата и время загрузки | - DEFAULT NOW()<br>- NOT NULL | 2020-05-05 10:00:00 |
| | **who_created** | `text` | Идентификатор пользователя админки, загрузившего файл | - NOT NULL | 0001dfed-3f44... |
| | **popularity** | `integer` | Количество запросов (для очистки неиспользуемых)<br><br>Сбрасывается раз в месяц | | 4 |


---

## Интеграция с другими микросервисами

Для интеграции необходимо написать **shared-библиотеку**, которая будет ходить в микросервис `MediaContent`.

Связь контента (товара/новости) с медиафайлами осуществляется через хранение идентификаторов в БД микросервисов контента (`Shop`, `News`, `Games`).

### Пример интеграции

В таблице сущности (например, `products` или `news`) создается поле `images` типа `jsonb` (или массив), где хранится список `id` файлов из `MediaContent`.

| Ключ | Поле | Тип | Описание | Параметры | Пример |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **PK**| **id** | `uuid` | Уникальный идентификатор контента<br>Не является идентификатором файла в `MediaContent` | - UNIQUE<br>- NOT NULL | 12345abc-678h... |
| **FK** | **images**| `jsonb` | Идентификаторы медиафайлов (из `MediaContent`) | |  {<br>"00002afb-846e...",<br>"00001afb-123e..."<br>} |

### ER-диаграмма

```mermaid
erDiagram
    integration_system }o--o{ media_files : "Многое ко многим"

    integration_system {
        UUID id PK
        jsonb images FK
    }

    media_files {
       UUID id PK, FK
        text slug
        text url
        jsonb metadata
        timestamp when_created
        text who_created
        integer popularity
    }

```


---

## Процессы (Data Flow)

### 1. Запись и обновление медиа в Админке

Процесс TO BE будет схож с AS IS.

1.  При загрузке медиафайла (создание/редактирование) `Webclient-Admin` отправляет POST-запрос в `MediaContent`.
2.  `MediaContent` генерирует `uuid`, сохраняет файл на CDN.
3.  `MediaContent` возвращает `uuid` в `Webclient-Admin`.
4.  При сохранении товара `Webclient-Admin` отправляет POST-запрос в микросервис контента (`Webshop`), передавая `uuid` медиафайла.

```mermaid
sequenceDiagram
    autonumber
    actor Admin as Администратор
    participant WA as WebClient-Admin
    participant MC as MediaContent
    participant CDN
    participant WS as Webshop (Content DB)

    Admin->>WA: Загрузка файла
    WA->>MC: POST /upload (File)
    MC->>MC: Генерация UUID
    MC->>CDN: Сохранение файла
    MC-->>WA: Возврат UUID
    
    Admin->>WA: Сохранить товар/новость
    WA->>WS: POST /save (Content Data + UUIDs)
    WS->>WS: Сохранение ID файлов в JSONB
```

### 2. Отображение пользователю (Сравнение)

#### AS IS (Текущая реализация)
Очень сложный флоу: `Webclient` -> `Media` -> `Webshop` -> `Localizator` -> `Regions` -> Возврат данных -> `Webclient` собирает ссылку на CDN из `ImageGroup`.

#### TO BE (Целевое решение)
Упрощенная схема с обогащением данных на бэкенде.

1.  Пользователь открывает страницу.
2.  `Webclient` запрашивает товар у `Webshop`.
3.  `Webshop` извлекает массив ID изображений из своей БД.
4.  `Webshop` обращается в `MediaContent` (через shared-lib), чтобы "обогатить" данные — получить полные URL по списку ID.
5.  Ответ от `MediaContent` кэшируется на стороне `Webshop`.
6.  `Webshop` возвращает на фронт полные данные с готовыми ссылками.

```mermaid
sequenceDiagram
    title TO BE: Получение медиаконтента
    actor User as Пользователь
    participant WP as WebClient-Platform
    participant WS as Webshop
    participant MC as MediaContent
    participant CDN

    User->>WP: Открыть страницу товара
    WP->>WS: GET /product/{id}
    
    Note over WS: Извлекает массив ID картинок из БД
    
    WS->>MC: Запрос URL по списку ID (Batch)
    MC-->>WS: Возврат списка URL
    
    Note over WS: Кэширование ответа
    
    WS-->>WP: Ответ (Данные товара + Полные URL)
    WP->>CDN: Загрузка изображений по URL
    CDN-->>User: Отображение контента
```

---

## Необходимые эндпоинты

### Public API
*   **Отображение на платформе**
    *   Input: `Payload: [uuid, uuid, ...]` (массив ID)
    *   Output: `Response: ["url1", "url2", ...]` (ссылки на CDN)

### Admin API
*   **Отображение в админке**
    *   Input: `Payload: [uuid, ...]`
    *   Output: `Response: ["url1", ...]`
*   **Сохранение медиафайла**
    *   Input: `Payload: File` (сам файл)
    *   Output: `Response: uuid`

---

## Оценка реализации

### Верхнеуровневая оценка
*   **Backend:** 20-30 sp (4-6 недель)
*   **Frontend:** 10 sp (2 недели)

### Детализация задач
**Backend:**
1.  Разработать новый микросервис со своей БД.
2.  Написать shared-библиотеку для интеграции.
3.  Реализовать интеграцию с сервисами (`Shop`, `News`, `Game`).
4.  Job для автоматической очистки CDN и БД.

**Frontend:**
1.  Актуализировать логику загрузки, обновления, получения, удаления медиафайлов (в WEB и Admin-Panel).

---

## Дальнейшее развитие

*   Подключение к новым/разрабатываемым контентным микросервисам (масштабируемость).
*   При объединении продуктов возможна реализация единого подхода к динамическому контенту и доступности.

---

## Решение по предложению

### Основание
> [!IMPORTANT]
> *Решение будет принято на Архитектурном комитете 30 июл. 2025 г.*
